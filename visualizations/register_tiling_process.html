<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Register Tiling - Fixed</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .header {
            background: linear-gradient(135deg, #1a9c09 0%, #1a9c09 100%);
            color: white;
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #2980b9;
        }
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        .iteration-info {
            background: #e3f2fd;
            border: 2px solid #2196f3;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 18px;
            font-weight: bold;
        }
        .thread-selector {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        .thread-btn {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #ddd;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }
        .thread-btn.active {
            transform: scale(1.05);
        }
        .thread-btn.t00.active { background: #ffebee; border-color: #e74c3c; color: #c62828; }
        .thread-btn.t01.active { background: #e3f2fd; border-color: #3498db; color: #1565c0; }
        .thread-btn.t10.active { background: #e8f5e9; border-color: #2ecc71; color: #2e7d32; }
        .thread-btn.t11.active { background: #fff3e0; border-color: #f39c12; color: #e65100; }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .full-width {
            grid-column: 1 / -1;
        }
        h3 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        .matrix-container {
            text-align: center;
            margin: 20px 0;
        }
        .matrix-grid {
            display: inline-grid;
            gap: 4px;
            padding: 12px;
            background: #ecf0f1;
            border-radius: 6px;
        }
        .cell {
            background: white;
            padding: 12px;
            text-align: center;
            font-family: 'Courier New', monospace;
            border-radius: 4px;
            min-width: 50px;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            border: 2px solid transparent;
        }
        .cell.load-t00 { background: #ffcdd2; border-color: #e74c3c; transform: scale(1.1); }
        .cell.load-t01 { background: #bbdefb; border-color: #3498db; transform: scale(1.1); }
        .cell.load-t10 { background: #c8e6c9; border-color: #2ecc71; transform: scale(1.1); }
        .cell.load-t11 { background: #fff59d; border-color: #f39c12; transform: scale(1.1); }
        .thread-tile {
            background: #f8f9fa;
            border: 3px solid;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        .thread-tile.t00 { border-color: #e74c3c; }
        .thread-tile.t01 { border-color: #3498db; }
        .thread-tile.t10 { border-color: #2ecc71; }
        .thread-tile.t11 { border-color: #f39c12; }
        .tile-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            margin: 10px 0;
        }
        .tile-cell {
            background: white;
            padding: 15px;
            text-align: center;
            font-family: 'Courier New', monospace;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            border: 2px solid #ddd;
            transition: all 0.3s;
        }
        .tile-cell.updating {
            background: #c8e6c9;
            border-color: #4caf50;
            animation: pulse 0.5s;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .calculation-display {
            background: #e8f5e9;
            border: 2px solid #4caf50;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.8;
        }
        .vectors-display {
            background: #fff3cd;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        .final-matrix .matrix-grid {
            grid-template-columns: repeat(4, 1fr);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 style="margin: 0;"> Interactive Register Tiling - Per Thread View</h1>
        <p style="margin: 10px 0 0 0;">Watch each thread load ONLY 2+2=4 elements and compute 2√ó2 outer product!</p>
    </div>

    <div class="controls">
        <div class="iteration-info" id="iterationInfo">
            Select a thread and click "Next" to see what IT loads
        </div>
        <div class="thread-selector">
            <strong>Select Thread to Watch:</strong><br>
            <button class="thread-btn t00 active" onclick="selectThread('t00')">üî¥ T(0,0)</button>
            <button class="thread-btn t01" onclick="selectThread('t01')">üîµ T(0,1)</button>
            <button class="thread-btn t10" onclick="selectThread('t10')">üü¢ T(1,0)</button>
            <button class="thread-btn t11" onclick="selectThread('t11')">üü° T(1,1)</button>
        </div>
        <div style="margin-top: 15px;">
            <button onclick="reset()" id="resetBtn">üîÑ Reset</button>
            <button onclick="previousStep()" id="prevBtn" disabled>‚¨ÖÔ∏è Previous</button>
            <button onclick="nextStep()" id="nextBtn">‚ñ∂Ô∏è Next Step</button>
        </div>
    </div>

    <div class="main-content">
        <div class="section">
            <h3>Matrix A (4√ó4)</h3>
            <div class="matrix-container">
                <div class="matrix-grid" style="grid-template-columns: repeat(4, 1fr);" id="matrixA"></div>
            </div>
            <p style="text-align: center; color: #666; font-size: 14px;">
                Highlighted = 2 elements loaded by selected thread
            </p>
        </div>

        <div class="section">
            <h3>Matrix B (4√ó4)</h3>
            <div class="matrix-container">
                <div class="matrix-grid" style="grid-template-columns: repeat(4, 1fr);" id="matrixB"></div>
            </div>
            <p style="text-align: center; color: #666; font-size: 14px;">
                Highlighted = 2 elements loaded by selected thread
            </p>
        </div>
    </div>

    <div class="section full-width">
        <h3>Selected Thread Details</h3>
        <div id="threadDetails"></div>
    </div>

    <div class="section full-width">
        <h3>All Thread Register Tiles</h3>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;" id="allThreads"></div>
    </div>

    <div class="section full-width">
        <h3>Final Result: Matrix C (4√ó4)</h3>
        <div class="matrix-container final-matrix">
            <div class="matrix-grid" style="grid-template-columns: repeat(4, 1fr);" id="matrixC"></div>
        </div>
    </div>

    <script>
        const A = [
            [1, 2, 3, 4],
            [5, 6, 7, 8],
            [9, 10, 11, 12],
            [13, 14, 15, 16]
        ];

        const B = [
            [13, 14, 15, 16],
            [9, 10, 11, 12],
            [5, 6, 7, 8],
            [1, 2, 3, 4]
        ];

        let currentK = -1;
        let selectedThread = 't00';
        let autoPlayInterval = null;
        let allThreadsVisible = false;

        const threads = {
            't00': { row: 0, col: 0, name: 'T(0,0)', color: 'red', tiles: [[0,0],[0,0]] },
            't01': { row: 0, col: 2, name: 'T(0,1)', color: 'blue', tiles: [[0,0],[0,0]] },
            't10': { row: 2, col: 0, name: 'T(1,0)', color: 'green', tiles: [[0,0],[0,0]] },
            't11': { row: 2, col: 2, name: 'T(1,1)', color: 'yellow', tiles: [[0,0],[0,0]] }
        };

        function initializeMatrices() {
            renderMatrix('matrixA', A);
            renderMatrix('matrixB', B);
            renderMatrix('matrixC', [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]);
            renderAllThreads();
            updateThreadDetails();
        }

        function renderMatrix(id, matrix) {
            const container = document.getElementById(id);
            container.innerHTML = '';
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `${id}_${i}_${j}`;
                    cell.textContent = matrix[i][j];
                    container.appendChild(cell);
                }
            }
        }

        function renderAllThreads() {
            const container = document.getElementById('allThreads');
            container.innerHTML = '';
            
            Object.keys(threads).forEach(tid => {
                const thread = threads[tid];
                const div = document.createElement('div');
                div.className = `thread-tile ${tid}`;
                div.innerHTML = `
                    <h4 style="margin: 0 0 10px 0;">${thread.name} ‚Üí C[${thread.row}:${thread.row+2}][${thread.col}:${thread.col+2}]</h4>
                    <div class="tile-grid">
                        <div class="tile-cell" id="${tid}_0_0">0</div>
                        <div class="tile-cell" id="${tid}_0_1">0</div>
                        <div class="tile-cell" id="${tid}_1_0">0</div>
                        <div class="tile-cell" id="${tid}_1_1">0</div>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        function selectThread(tid) {
            selectedThread = tid;
            initializeMatrices();
            document.querySelectorAll('.thread-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.thread-btn.${tid}`).classList.add('active');
            
            if (currentK >= 0) {
                showThreadAtK(currentK);
            } else {
                updateThreadDetails();
            }
        }

        function updateThreadDetails() {
            const thread = threads[selectedThread];
            document.getElementById('threadDetails').innerHTML = `
                <div class="thread-tile ${selectedThread}">
                    <h3>${thread.name}: Computing C[${thread.row}:${thread.row+2}][${thread.col}:${thread.col+2}]</h3>
                    <p>Thread position in layout: row=${thread.row/2}, col=${thread.col/2}</p>
                    <p>Starting row in matrix: ${thread.row}, Starting col in matrix: ${thread.col}</p>
                    <p style="margin-top: 15px; font-style: italic;">Click "Next Step" to see what this thread loads...</p>
                </div>
            `;
        }

        function nextStep() {
            if (currentK < 3) {
                currentK++;
                showThreadAtK(currentK,"NEXT");
                // updateAllThreads(currentK);
                if (allThreadsVisible) {

                    updateAllThreads(currentK);
                }
                else{
                    
                }
                updateSelectedThreads(currentK, selectedThread);
                updateButtons();
            }
        }

      

        function previousStep() {
            if (currentK > 0) {
                currentK--;
                showThreadAtK(currentK,"PREV");
                if (allThreadsVisible) {
                    recalculateUpToK(currentK);
                } else{

                    recalculateSelectedThreadUpToK(currentK, selectedThread);
                }
                updateButtons();
            } else if (currentK === 0) {
                reset();
            }
        }

        

        function recalculateUpToK(upToK) {
            Object.keys(threads).forEach(tid => {
                threads[tid].tiles = [[0,0],[0,0]];
            });
            
            for (let k = 0; k <= upToK; k++) {
                Object.keys(threads).forEach(tid => {
                    const thread = threads[tid];
                    const a_vec = [A[thread.row][k], A[thread.row + 1][k]];
                    const b_vec = [B[k][thread.col], B[k][thread.col + 1]];
                    
                    for (let i = 0; i < 2; i++) {
                        for (let j = 0; j < 2; j++) {
                            thread.tiles[i][j] += a_vec[i] * b_vec[j];
                        }
                    }
                });
            }
            
            updateAllThreadsDisplay();
            updateFinalMatrix();
        }


        function recalculateSelectedThreadUpToK(upToK, tid) {
            Object.keys(threads).forEach(tid => {
                threads[tid].tiles = [[0,0],[0,0]];
            });
            
            for (let k = 0; k <= upToK; k++) {
                const thread = threads[tid];
                const a_vec = [A[thread.row][k], A[thread.row + 1][k]];
                const b_vec = [B[k][thread.col], B[k][thread.col + 1]];
                    
                    for (let i = 0; i < 2; i++) {
                        for (let j = 0; j < 2; j++) {
                            thread.tiles[i][j] += a_vec[i] * b_vec[j];
                        }
                    }
                
            }
            
            updateSelectedThreadsDisplay(tid);
            updateFinalMatrix();
        }

        function showThreadAtK(k,direction) {
            clearHighlights();
            const thread = threads[selectedThread];
            
            document.getElementById('iterationInfo').innerHTML = 
                `<strong>k=${k}</strong> ‚Ä¢ Watching ${thread.name} ‚Ä¢ Loads 2 from A, 2 from B`;

            // Highlight ONLY the 2 elements this thread loads from A
            highlightCell('matrixA', thread.row, k, selectedThread);
            highlightCell('matrixA', thread.row + 1, k, selectedThread);

            // Highlight ONLY the 2 elements this thread loads from B
            highlightCell('matrixB', k, thread.col, selectedThread);
            highlightCell('matrixB', k, thread.col + 1, selectedThread);

            // Show what this thread loads and computes
            let a_vec, b_vec;
            if (direction === "NEXT") {
             a_vec = [A[thread.row][k], A[thread.row + 1][k]];
             b_vec = [B[k][thread.col], B[k][thread.col + 1]];
            } else {
                a_vec = [A[thread.row][k+1], A[thread.row + 1][k+1]];
                b_vec = [B[k+1][thread.col], B[k+1][thread.col + 1]];
            }
            let details = `
                <div class="thread-tile ${selectedThread}">
                    <h3>${thread.name} at k=${k}</h3>
                    <div class="vectors-display">
                        <strong>Loads ONLY 2+2=4 elements:</strong><br>
                        a_vec = [A[${thread.row}][${k}], A[${thread.row+1}][${k}]] = [${a_vec[0]}, ${a_vec[1]}]<br>
                        b_vec = [B[${k}][${thread.col}], B[${k}][${thread.col+1}]] = [${b_vec[0]}, ${b_vec[1]}]
                    </div>
                    <div class="calculation-display">
                        <strong>Computes 2√ó2 Outer Product:</strong><br>
            `;

            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 2; j++) {
                    const product = a_vec[i] * b_vec[j];
                    const oldVal = k === 0 ? 0 : thread.tiles[i][j] ;
                    if (direction === "NEXT") {
                        details += `c[${i}][${j}]: ${oldVal} + ${a_vec[i]}√ó${b_vec[j]} = ${thread.tiles[i][j]+product}<br>`;
                    } else {
                        details += `c[${i}][${j}]:  = ${thread.tiles[i][j]} - ${a_vec[i]}√ó${b_vec[j]} = ${thread.tiles[i][j]-product}<br>`;
                    }
                }
            }

            details += `
                    </div>
                </div>
            `;

            document.getElementById('threadDetails').innerHTML = details;
        }

        function highlightCell(matrixId, row, col, threadId) {
            const cell = document.getElementById(`${matrixId}_${row}_${col}`);
            cell.classList.add(`load-${threadId}`);
        }

        function updateAllThreads(k) {
            Object.keys(threads).forEach(tid => {
                const thread = threads[tid];
                const a_vec = [A[thread.row][k], A[thread.row + 1][k]];
                const b_vec = [B[k][thread.col], B[k][thread.col + 1]];
                
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 2; j++) {
                        thread.tiles[i][j] += a_vec[i] * b_vec[j];
                    }
                }
            });
            
            updateAllThreadsDisplay();
            setTimeout(() => updateFinalMatrix(), 300);
        }


         function updateSelectedThreads(k, tid) {
            const thread = threads[tid];
            const a_vec = [A[thread.row][k], A[thread.row + 1][k]];
            const b_vec = [B[k][thread.col], B[k][thread.col + 1]];

                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 2; j++) {
                        thread.tiles[i][j] += a_vec[i] * b_vec[j];
                    }
                }
            
            updateSelectedThreadsDisplay(tid);
            setTimeout(() => updateFinalMatrix(), 300);
        }

        function updateAllThreadsDisplay() {
            Object.keys(threads).forEach(tid => {
                const thread = threads[tid];
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 2; j++) {
                        const cell = document.getElementById(`${tid}_${i}_${j}`);
                        cell.textContent = thread.tiles[i][j];
                        cell.classList.add('updating');
                        setTimeout(() => cell.classList.remove('updating'), 500);
                    }
                }
            });
        }

        function updateSelectedThreadsDisplay(tid) {
            const thread = threads[tid];
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 2; j++) {
                    const cell = document.getElementById(`${tid}_${i}_${j}`);
                        cell.textContent = thread.tiles[i][j];
                        cell.classList.add('updating');
                        setTimeout(() => cell.classList.remove('updating'), 500);
                    }
                }
        }

        

        function updateFinalMatrix() {
            Object.keys(threads).forEach(tid => {
                const thread = threads[tid];
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 2; j++) {
                        const globalRow = thread.row + i;
                        const globalCol = thread.col + j;
                        const cell = document.getElementById(`matrixC_${globalRow}_${globalCol}`);
                        cell.textContent = thread.tiles[i][j];
                        cell.classList.add('updating');
                        setTimeout(() => cell.classList.remove('updating'), 500);
                        
                        cell.style.background = tid === 't00' ? '#ffebee' :
                                               tid === 't01' ? '#e3f2fd' :
                                               tid === 't10' ? '#e8f5e9' : '#fff3e0';
                    }
                }
            });
        }

        function clearHighlights() {
            document.querySelectorAll('.cell[class*="load-"]').forEach(cell => {
                cell.className = 'cell';
            });
        }

        function reset() {
            currentK = -1;
            Object.keys(threads).forEach(tid => {
                threads[tid].tiles = [[0, 0], [0, 0]];
            });
            initializeMatrices();
            document.getElementById('iterationInfo').innerHTML = 
                'Select a thread and click "Next" to see Computations step-by-step';
            updateButtons();
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
                document.getElementById('autoBtn').textContent = '‚èØÔ∏è All Threads';
            }
        }

       

        function updateButtons() {
            document.getElementById('prevBtn').disabled = currentK < 0;
            document.getElementById('nextBtn').disabled = currentK >= 3;
            
            if (currentK >= 3) {
                document.getElementById('iterationInfo').innerHTML = 
                    '<strong>‚úì Complete!</strong> All K=4 iterations finished';
            }
        }

        initializeMatrices();
    </script>
</body>
</html>
